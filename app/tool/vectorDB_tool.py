from typing import Dict, List, Optional, Union
from app.tool.ai_tool import get_ai_tool, AITool
from app.core.weaviate_client import get_weaviate_client
import weaviate
from weaviate.classes.query import Filter
import logging
import asyncio
from app.core.config import settings

# Configure global logger
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

# Add handler if none exists to avoid duplicate handlers
if not logger.handlers:
    handler = logging.StreamHandler()
    handler.setFormatter(logging.Formatter("%(asctime)s - %(levelname)s - %(message)s"))
    logger.addHandler(handler)


async def store_vector_record(
    items: Union[Dict, List[Dict]],
    ai_tool: AITool = None,
    weaviate_client: weaviate.Client = None,
) -> Union[Dict, List[Dict]]:
    """
    Store vector record in Weaviate with embeddings generated by AI.

    Args:
        items: Single dictionary or list of dictionaries containing vector records to store.
               Each item should have: content, source, knowledge_type, and optional metadata
        ai_tool: Optional AITool instance
        weaviate_client: Optional Weaviate client instance

    Returns:
        Dict or List[Dict] containing the stored vector record information
    """
    if ai_tool is None:
        ai_tool = get_ai_tool()
    if weaviate_client is None:
        weaviate_client = get_weaviate_client();
    
    weaviate_client.connect();

    # Convert single item to list for consistent processing
    items_list = [items] if isinstance(items, dict) else items

    # Get the knowledge collection
    collection = weaviate_client.collections.get(
        settings.GENERAL_KNOWLEDGE_COLLECTION_NAME
    )

    results = []
    for item in items_list:
        content = item.get("content")
        source = item.get("source")
        knowledge_type = item.get("knowledge_type")
        metadata = item.get("metadata", {})

        if not all([content, source, knowledge_type]):
            raise ValueError(
                "Missing required fields: content, source, or knowledge_type"
            )

        # Generate embeddings for the content
        embeddings = await ai_tool.get_embeddings(content)

        try:
            # Insert the object using data.insert()
            result = collection.data.insert(
                properties={
                    "content": content,
                    "source": source,
                    "knowledge_type": knowledge_type,
                    "metadata": metadata,
                },
                vector=embeddings,
            )

            if result:
                logger.info(
                    f"Successfully stored vector record - Source: {source}, Type: {knowledge_type}"
                )
                results.append({"status": "success", "data": item})
            else:
                logger.error(
                    f"Failed to store vector record - Source: {source}, Type: {knowledge_type}"
                )
                results.append(
                    {"status": "error", "data": item, "message": "Insert failed"}
                )

        except Exception as e:
            logger.error(
                f"Error storing vector record: {str(e)} - Source: {source}, Type: {knowledge_type}"
            )
            results.append({"status": "error", "data": item, "message": str(e)})

    return results[0] if len(results) == 1 else results


async def retrieve_vector_record(
    query: str,
    limit: int = 5,
    filters: Optional[List[Filter]] = None,
    ai_tool: AITool = None,
    weaviate_client: weaviate.Client = None,
) -> List[Dict]:
    """
    Retrieve vector records from Weaviate using semantic search.

    Args:
        query: The search query
        limit: Maximum number of results to return
        filters: Optional list of Weaviate filters
        ai_tool: Optional AITool instance
        weaviate_client: Optional Weaviate client instance

    Returns:
        List of retrieved vector records
    """
    if ai_tool is None:
        ai_tool = get_ai_tool()
    if weaviate_client is None:
        weaviate_client = get_weaviate_client();
    
    weaviate_client.connect();

    # Generate embeddings for the query
    query_embeddings = await ai_tool.get_embeddings(query)

    # Get the knowledge collection
    collection = weaviate_client.collections.get(
        settings.GENERAL_KNOWLEDGE_COLLECTION_NAME
    )

    # Prepare the query
    query_builder = collection.query.near_vector(
        vector=query_embeddings, limit=limit
    )

    # Apply filters if provided
    if filters:
        for filter_condition in filters:
            query_builder = query_builder.with_filter(filter_condition)

    # Execute the query
    result = query_builder.do()

    # Format the results
    vector_records = []
    for item in result.objects:
        vector_records.append(
            {
                "id": item.uuid,
                "content": item.properties.get("content"),
                "source": item.properties.get("source"),
                "knowledge_type": item.properties.get("knowledge_type"),
                "metadata": item.properties.get("metadata", {}),
                "distance": item.metadata.distance,
            }
        )

    return vector_records


async def delete_vector_record(
    record_id: str, weaviate_client: weaviate.Client = None
) -> Dict:
    """
    Delete vector record from Weaviate by ID.

    Args:
        record_id: ID of the vector record to delete
        weaviate_client: Optional Weaviate client instance

    Returns:
        Dict containing the deletion status
    """
    if weaviate_client is None:
        weaviate_client = get_weaviate_client();
    
    weaviate_client.connect();

    # Get the knowledge collection
    collection = weaviate_client.collections.get(
        settings.GENERAL_KNOWLEDGE_COLLECTION_NAME
    )

    try:
        # Delete the object
        collection.data.delete(record_id)
        return {
            "status": "success",
            "message": f"Vector record with ID {record_id} deleted successfully",
        }
    except Exception as e:
        return {"status": "error", "message": f"Failed to delete vector record: {str(e)}"}


async def update_vector_record(
    record_id: str,
    content: Optional[str] = None,
    metadata: Optional[Dict] = None,
    ai_tool: AITool = None,
    weaviate_client: weaviate.Client = None,
) -> Dict:
    """
    Update existing vector record in Weaviate.

    Args:
        record_id: ID of the vector record to update
        content: Optional new content
        metadata: Optional new metadata
        ai_tool: Optional AITool instance
        weaviate_client: Optional Weaviate client instance

    Returns:
        Dict containing the update status
    """
    if ai_tool is None:
        ai_tool = get_ai_tool()
    if weaviate_client is None:
        weaviate_client = get_weaviate_client();
    
    weaviate_client.connect();

    # Get the knowledge collection
    collection = weaviate_client.collections.get(
        settings.GENERAL_KNOWLEDGE_COLLECTION_NAME
    )

    try:
        # Get existing object
        existing_object = collection.query.fetch_object_by_id(record_id)
        if not existing_object:
            return {
                "status": "error",
                "message": f"Vector record with ID {record_id} not found",
            }

        # Prepare update data
        update_data = {}
        if content is not None:
            update_data["content"] = content
        if metadata is not None:
            update_data["metadata"] = metadata

        # Generate new embeddings if content is updated
        new_embeddings = None
        if content is not None:
            new_embeddings = await ai_tool.get_embeddings(content)

        # Update the object
        collection.data.update(
            uuid=record_id, properties=update_data, vector=new_embeddings
        )

        return {
            "status": "success",
            "message": f"Vector record with ID {record_id} updated successfully",
        }
    except Exception as e:
        return {"status": "error", "message": f"Failed to update vector record: {str(e)}"}


async def store_vector_record_batch(
    record_items: List[Dict],
    batch_size: int = 10,
    max_workers: int = 5,
    ai_tool: AITool = None,
    weaviate_client: weaviate.Client = None,
) -> List[Dict]:
    """
    Process and store multiple vector records in batches using parallel processing.

    Args:
        record_items: List of dictionaries containing vector records to store
        batch_size: Number of items to process in each batch
        max_workers: Maximum number of concurrent workers
        ai_tool: Optional AITool instance
        weaviate_client: Optional Weaviate client instance

    Returns:
        List of results from storing each vector record
    """


    if ai_tool is None:
        ai_tool = get_ai_tool()
    if weaviate_client is None:
        weaviate_client = get_weaviate_client();
    
    weaviate_client.connect();

    async def process_batch(batch: List[Dict]) -> List[Dict]:
        try:
            # Store the batch using the new store_vector_record functionality
            results = await store_vector_record(
                items=batch, ai_tool=ai_tool, weaviate_client=weaviate_client
            )

            # Ensure results is a list
            if isinstance(results, dict):
                results = [results]

            # Log batch results
            success_count = sum(1 for r in results if r.get("status") == "success")
            logger.info(
                f"Processed batch of {len(batch)} items. Success: {success_count}, Errors: {len(batch) - success_count}"
            )

            return results

        except Exception as e:
            logger.error(f"Error processing batch: {str(e)}")
            return [
                {"status": "error", "data": item, "message": str(e)} for item in batch
            ]

    # Split items into batches
    batches = [
        record_items[i : i + batch_size]
        for i in range(0, len(record_items), batch_size)
    ]

    # Use semaphore to limit concurrent batches
    semaphore = asyncio.Semaphore(max_workers)

    async def process_batch_with_semaphore(batch):
        async with semaphore:
            return await process_batch(batch)

    # Process all batches with controlled concurrency
    results = await asyncio.gather(
        *[process_batch_with_semaphore(batch) for batch in batches]
    )

    # Flatten results
    flattened_results = [item for batch_result in results for item in batch_result]

    # Log summary
    success_count = sum(1 for r in flattened_results if r.get("status") == "success")
    error_count = len(flattened_results) - success_count
    logger.info(f"Processing complete. Success: {success_count}, Errors: {error_count}")

    return flattened_results


async def get_vector_record_by_filters(
    filters: Union[Filter, List[Filter]],
    limit: int = 10,
    weaviate_client: weaviate.Client = None,
) -> List[Dict]:
    """
    Retrieve vector records from Weaviate using filters.

    Args:
        filters: Single Filter or list of Filters to apply. Can be a single Filter,
                a list of Filters, or a Filter.all_of() combination
        limit: Maximum number of results to return
        weaviate_client: Optional Weaviate client instance

    Returns:
        List of retrieved vector records
    """
    if weaviate_client is None:
        weaviate_client = get_weaviate_client();
    
    weaviate_client.connect();

    # Get the knowledge collection
    collection = weaviate_client.collections.get(
        settings.GENERAL_KNOWLEDGE_COLLECTION_NAME
    )

    weaviate_filters = []

    for filter_condition in filters:
        # Convert path to string if it's a list
        path = (
            filter_condition.path[0]
            if isinstance(filter_condition.path, list)
            else filter_condition.path
        )

        # Create the appropriate filter based on the operator
        if filter_condition.operator == "Equal":
            weaviate_filters.append(
                Filter.by_property(path).equal(filter_condition.value)
            )
        elif filter_condition.operator == "NotEqual":
            weaviate_filters.append(
                Filter.by_property(path).not_equal(filter_condition.value)
            )
        elif filter_condition.operator == "GreaterThan":
            weaviate_filters.append(
                Filter.by_property(path).greater_than(filter_condition.value)
            )
        elif filter_condition.operator == "LessThan":
            weaviate_filters.append(
                Filter.by_property(path).less_than(filter_condition.value)
            )
        elif filter_condition.operator == "ContainsAny":
            weaviate_filters.append(
                Filter.by_property(path).contains_any(filter_condition.value)
            )
        elif filter_condition.operator == "ContainsAll":
            weaviate_filters.append(
                Filter.by_property(path).contains_all(filter_condition.value)
            )
        else:
            raise ValueError(f"Unsupported operator: {filter_condition.operator}")

    # Get vector records using the filters
    results = collection.query.fetch_objects(
        filters=Filter.all_of(weaviate_filters), limit=limit
    )

    # Format the results
    vector_records = []
    for item in results.objects:
        vector_records.append(
            {
                "id": item.uuid,
                "content": item.properties.get("content"),
                "source": item.properties.get("source"),
                "knowledge_type": item.properties.get("knowledge_type"),
                "metadata": item.properties.get("metadata", {}),
                "creation_time": item.metadata.creation_time,
                "last_update_time": item.metadata.last_update_time,
            }
        )

    logger.info(f"Retrieved {len(vector_records)} items matching the filters")
    return vector_records

async def store_vector_record_with_tenant_id(
    items: Union[Dict, List[Dict]],
    tenant_id: str,
    collection_name: str = settings.TENANT_KNOWLEDGE_COLLECTION_NAME,
    ai_tool: AITool = None,
) -> Union[Dict, List[Dict]]:
    """
    Store vector record in Weaviate with embeddings generated by AI, specifying collection and tenant.

    Args:
        items: Single dictionary or list of dictionaries containing vector records to store.
               Each item should have: content, source, knowledge_type, and optional metadata
        collection_name: Name of the Weaviate collection to store in
        tenant_id: ID of the tenant to store under
        ai_tool: Optional AITool instance
        weaviate_client: Optional Weaviate client instance

    Returns:
        Dict or List[Dict] containing the stored vector record information
    """
    if ai_tool is None:
        ai_tool = get_ai_tool()

    weaviate_client = get_weaviate_client();
    


    # Convert single item to list for consistent processing
    items_list = [items] if isinstance(items, dict) else items

    # Get the knowledge collection
    collection = weaviate_client.collections.get(collection_name);
    tenant = collection.tenants.get_by_name(tenant_id);

    if(tenant is None):
        print(f"Tenant {tenant_id} not found, creating new tenant");
        collection.tenants.create(tenant_id)
    
    tenant_collection = collection.with_tenant(tenant_id);


    results = []

    async def process_item(item):
        try:

            content = item.get("content")
            source = item.get("source")
            knowledge_type = item.get("knowledge_type")
            metadata = item.get("metadata", {})
            if not all([content, source, knowledge_type]):
                raise ValueError(
                    "Missing required fields: content, source, or knowledge_type"
                )

            embeddings = await ai_tool.get_embeddings(content)

            # Insert the object using data.insert() with tenant
            response = tenant_collection.data.insert(
                properties={
                    "content": content,
                    "source": source,
                    "knowledge_type": knowledge_type,
                    "metadata": metadata,
                },
                vector=embeddings,
            )

            if response:
                logger.info(
                    f"Successfully stored vector record - ITEM: {item.get("metadata").get("source_id")}, Type: {knowledge_type}, Tenant: {tenant_id}"
                )
                results.append(
                    {"status": "success", "data": item.get("metadata").get("source_id")}
                )
            else:
                logger.error(
                    f"Failed to store vector record - Source: {source}, Type: {knowledge_type}, Tenant: {tenant_id}"
                )
                results.append(
                    {
                        "status": "error",
                        "data": item.get("metadata").get("id"),
                        "message": "Insert failed",
                    }
                )

        except Exception as e:
            logger.error(
                f"Error storing vector record: {item.get("metadata").get("id")}, Type: {knowledge_type}, Tenant: {tenant_id}, Error: {str(e)}"
            )
            results.append(
                {
                    "status": "error",
                    "data": item.get("metadata").get("id"),
                    "message": str(e),
                }
            )

    await asyncio.gather(*[process_item(item) for item in items_list])
    weaviate_client.close();
    print('\033[41m\033[30mweaviate client closed \033[0m');

    return results[0] if len(results) == 1 else results

async def delete_vector_record_with_tenant_id(
    tenant_id: str,
    collection_name: str = settings.TENANT_KNOWLEDGE_COLLECTION_NAME
) -> Dict:
    """
    Delete all vector records from a specific tenant's knowledge base.
    """
    weaviate_client = get_weaviate_client();
    
    weaviate_client.connect();

    # Get the knowledge collection  
    
    try:
        # Delete all vector records from the collection
        collection = weaviate_client.collections.get(collection_name)
        collection.tenants.remove(tenant_id)

        print('\033[41m\033[30mweaviate client closed \033[0m');
        return {
            "status": "success",
            "message": f"All vector records from tenant {tenant_id} deleted successfully"
        }
    except Exception as e:
        print('\033[41m\033[30mweaviate client closed \033[0m');
        return {
            "status": "error",
            "message": f"Failed to delete vector records: {str(e)}"
        }
    finally:
        weaviate_client.close();
        print('\033[41m\033[30mweaviate client closed \033[0m');